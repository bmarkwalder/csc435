<!doctype html>
<html lang="en">
<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.3/css/bootstrap.min.css" integrity="sha384-Zug+QiDoJOrZ5t4lssLdxGhVrurbmBWopoEl+M6BdEfwnCJZtKxi1KgxUyJq13dy" crossorigin="anonymous">

    <title>Brandon Markwalder - Study Log</title>
</head>
<body>

<!-- Optional JavaScript -->
<!-- jQuery first, then Popper.js, then Bootstrap JS -->
<script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.3/js/bootstrap.min.js" integrity="sha384-a5N7Y/aK3qNeh15eJKGWxsqtnX/wWdSZSKp+81YjTmS15nvnvxKHuzaWwXHDli+4" crossorigin="anonymous"></script>

<div class="container">
    <div class="row">
        <div class="col-12">
            <h3>20 Concepts:</h3>
            <p class="font-weight-bold">01. Transparency:</p>
            <p>Transparency is an effort to make the distributed system invisible to the user. A main goal of transparency is to hide the architecture of the various systems in the distributed system. If the architecture is hidden that means an agreement is in place on how data is represented, meaning it does not matter what kind of machine, or operating system is currently involved in the system and reading or manipulating the data.</p>
            <p>There are several types of transparency to consider. Location transparency refers to not knowing the location of a data object, process, or thread within the system. URLs are a good example of location transparency. brandonmarkwalder.com tells the end user nothing about the fact that the files that drive my site sit on a virtual private server somewhere in New York. A related type is relocation transparency which simply states that the end user cannot tell if the files have been moved from one location to another. Concurrency transparency is the effect of hiding the use of shared files and resources. With concurrency transparency, Bob would not be aware that Alice is currently reading data from the same table as he is at the same time. Most importantly we have failure transparency, which prevents the user from knowing that a part of the system has failed. Failure transparency is generally difficult to achieve, mainly because it is often hard to distinguish between a process that has failed and one that is simply taking a long time to complete.</p>
            <p>Transparency is not always a good thing. The following example inspired by one provided in class demonstrates this concept swimmingly:</p>
            <p>You are developing a time lapse video of a seasonal change as a fun project with your toddler. The general workflow is to have the camera send a video stream to a remote location so you can review a dayâ€™s worth of images quickly and choose the one that best fits the motif of the film. However, that video stream goes down because a certain toddler unplugged the cable modem. Knowing that the system has a backup 2400 baud modem, you call your wife and tell her to hit the big red button which fires up the low bandwidth connection and tells the system to send a single image. Although we did not have a video stream to choose a best image from, we do still have the day captured, meaning the time lapse photo series completely captures the seasonal change.</p>

            <p class="font-weight-bold">02. Interface Definition Language (IDL):</p>
            <p>An IDL is a construct that helps open systems by defining the contract of the open system. The IDL defines an interface; input, output, return values, methods, data streams, and data types. IDLs allow contributing parties to the open system to remain free from implementation restrictions. IDLs are so carefully defined that they can be checked for syntax violations, as well as produce helper code such as client stubs and server skeletons. However, this helper code is a nice to have, a side effect of the contract. The whole point of an IDL is the agreement between the contributing parties on what the system will consume and produce. Any language, platform, architecture, etc. can be used in the open system, as long as the contract of the system (IDL) is respected. </p>

            <p class="font-weight-bold">03. Graphene device:</p>
            <p>Get the brain waves out to control devices.</p>


            <p class="font-weight-bold">04. :</p>
            <p class="font-weight-bold">05. :</p>
            <p class="font-weight-bold">06. :</p>
            <p class="font-weight-bold">07. :</p>
            <p class="font-weight-bold">08. :</p>
            <p class="font-weight-bold">09. :</p>
            <p class="font-weight-bold">10. :</p>
            <p class="font-weight-bold">11. :</p>
            <p class="font-weight-bold">12. :</p>
            <p class="font-weight-bold">13. :</p>
            <p class="font-weight-bold">14. :</p>
            <p class="font-weight-bold">15. :</p>
            <p class="font-weight-bold">16. :</p>
            <p class="font-weight-bold">17. :</p>
            <p class="font-weight-bold">18. :</p>
            <p class="font-weight-bold">19. :</p>
            <p class="font-weight-bold">20. :</p>

            <h3>Lecture notes:</h3>
            <h4>Lecture 01</h4>
            <p>There is almost always a compromise and there is no global clock. The following concepts are important but will not be covered in class and they will likely make good 20 concepts topics:</p>
            <li>Parallel Computing</li>
            <li>Grid Computing</li>
            <li>Cluster Computing</li>
            <li>Distributed Operating Systems</li>
            <li>Shared memory Systems</li>
            <li>Distributed Algorithms</li>
            <p></p>
            <p>The motivation behind distributed systems is to protect sensitive applications while leaving less sensitive applications more accessible.</p>
            <p>Boundary policies are like proxies.</p>
            <p>Middleware is the layer of software running independently on each computer but makes it appear as though the application is running on a single system.</p>
            <p>Transparency is an effort to make the distributed system invisible to the user, so the user cannot see the distributed system. Transparency is not always a good thing.</p>

            <h4>Lecture 02</h4>
            <p>Anyone can write to open systems. The interface is defined and anyone can write programs in any language that is able to talk to the system as long as they follow the rules. If we stick to the defined interface, the implementation remains open. Interface definition languages allow for this concept to work. Remember that the whole point of an open system is maintaining that policy is separate from implementation. Open systems should follow four basic principles:</p>
            <li>They must include defined requirements that allow all parties to implement their solutions</li>
            <li>Once defined, remain stable over the development period</li>
            <li>Interfaces are publically available, hence the word open in open systems</li>
            <li>There is not a single party that holds control over the system</li>
            <p></p>
            <p>When working with open systems, scalability should be of top concern. Especially in the administration of the system, which is often the bottle neck when you take a small system and scale it up. An example provided in class was taking our class of 70-80 students and blowing it up to 1000 students worldwide. Suddenly, we need multiple graders, which is cause for oversight to ensure that grading is performed in a consistent manner. Content suddenly needs to be evaluated to ensure it can legally be transmitted worldwide, etc.</p>
            <p>Fully distributed algorithms are difficult to implement for a variety of reasons, mainly because there is no global clock. General properties of a fully distributed algorithm are:</p>
            <li>There does not exist one machine that has all of the information about system, specifically the current state of the system</li>
            <li>Local machines will make decisions based only on the information that resides on the local system</li>
            <li>Failure of a single point will not make the entire system fail</li>
            <p></p>
            <p>Fully distributed algorithms are often buggier and slower, than local solutions. These properties are difficult to wrangle, so what is the incentive to attempt to implement a fully distributed algorithm? Because when they do work, they are awesome, so you should give it a shot.</p>
            <p>Thick vs Thin clients: Thin clients have little code stored client side resulting in more data transfer, which brings with it risk as there are more opportunities for exposure of data/information. Thick clients have more code stored client side, leading to greater risk of out dated code which can lead to insecure code remaining out in the wild.</p>
            <p>Synchronous vs Asynchronous: Synchronous are easy on a local system. If a client blocks on an open system that leads to trouble. Blocking calls are synchronous, meaning the caller and the called wait for each other to complete their tasks. If a client is blocked we cannot tell if the server blew up, so we should use an asynchronous call. In an asynchronous, the caller does not wait for the called to respond, it continues down its path. Asynchronous calls often require more complex logic.</p>
            <p>Latency is the amount of time for an empty packet to get from here to there.</p>
            <p>In transactions there is a before, and after, and nothing in between. To define that more concretely, think of the example provided where a user books a hotel, flight, and car rental. All three bookings are first not booked, then they are all booked. The transaction fails if only the hotel is booked.</p>

        </div>

    </div>
</div>


</body>
</html>